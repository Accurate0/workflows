name: "upload-object"
on:
  workflow_call:
    secrets:
      KEY_ID:
        required: true
      PRIVATE_KEY:
        required: true
    inputs:
      namespace:
        description: "The namespace"
        required: true
        type: string
      object-name:
        description: "The object name"
        required: true
        type: string
      object-path:
        description: "The path to the object file"
        required: false
        type: string
      object-content:
        description: "The content of the object as a string"
        required: false
        type: string
      api-url:
        description: "The API URL"
        required: false
        default: "https://object-registry.inf-k8s.net/v1"
        type: string
      public:
        description: "Whether the object is public"
        required: false
        default: false
        type: boolean
      labels:
        description: "Labels in key=value format, comma or newline separated"
        required: false
        type: string
      content-type:
        description: "The content type of the object"
        required: false
        type: string
      issuer:
        description: "The JWT issuer"
        required: false
        default: "github-action"
        type: string

jobs:
  upload-object:
    name: upload object to registry
    runs-on: ubuntu-latest
    steps:
      - name: upload object
        shell: bash
        env:
          KEY_ID: ${{ secrets.KEY_ID }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          NAMESPACE: ${{ inputs.namespace }}
          OBJECT_NAME: ${{ inputs.object-name }}
          OBJECT_PATH: ${{ inputs.object-path }}
          OBJECT_CONTENT: ${{ inputs.object-content }}
          API_URL: ${{ inputs.api-url }}
          PUBLIC: ${{ inputs.public }}
          LABELS: ${{ inputs.labels }}
          CONTENT_TYPE: ${{ inputs.content-type }}
          ISSUER: ${{ inputs.issuer }}
        run: |
          set -e

          # Write private key to a temporary file
          PK_FILE=$(mktemp)
          trap 'rm -f "$PK_FILE"' EXIT
          echo "$PRIVATE_KEY" > "$PK_FILE"

          # Handle object content vs path
          if [ -n "$OBJECT_CONTENT" ]; then
            TEMP_OBJECT_FILE=$(mktemp)
            trap 'rm -f "$PK_FILE" "$TEMP_OBJECT_FILE"' EXIT
            echo -n "$OBJECT_CONTENT" > "$TEMP_OBJECT_FILE"
            OBJECT_PATH="$TEMP_OBJECT_FILE"
          elif [ -z "$OBJECT_PATH" ]; then
            echo "Error: Either object-path or object-content must be provided."
            exit 1
          fi

          # Prepare JWT
          iat=$(date +%s)
          exp=$((iat + 900))

          header_json=$(printf '{"alg":"RS256","typ":"JWT","kid":"%s"}' "$KEY_ID")
          claims_json=$(printf '{"iat":%d,"exp":%d,"aud":"object-registry","iss":"%s","sub":"object-registry","role":["SERVICE"]}' "$iat" "$exp" "$ISSUER")

          base64_url_encode() {
            openssl enc -base64 -A | tr '+/' '-_' | tr -d '='
          }

          header_base64=$(echo -n "$header_json" | base64_url_encode)
          claims_base64=$(echo -n "$claims_json" | base64_url_encode)

          payload="${header_base64}.${claims_base64}"
          signature=$(echo -n "$payload" | openssl dgst -sha256 -sign "$PK_FILE" | base64_url_encode)

          JWT="${payload}.${signature}"

          # Prepare curl command
          URL="${API_URL%/}"
          if [ "$PUBLIC" = "true" ]; then
            URL="${URL}/${NAMESPACE}/public/${OBJECT_NAME}"
          else
            URL="${URL}/${NAMESPACE}/${OBJECT_NAME}"
          fi

          # Build curl arguments
          CURL_OPTS=("-s" "-f" "-X" "PUT" "-H" "Authorization: Bearer $JWT")

          if [ -n "$CONTENT_TYPE" ]; then
            CURL_OPTS+=("-H" "Content-Type: $CONTENT_TYPE")
          fi

          # Add labels
          if [ -n "$LABELS" ]; then
            # Split by comma or newline
            echo "$LABELS" | tr ',' '\n' | while IFS= read -r label; do
              if [ -n "$label" ]; then
                key=$(echo "$label" | cut -d'=' -f1 | xargs)
                val=$(echo "$label" | cut -d'=' -f2- | xargs)
                CURL_OPTS+=("-H" "x-label-$key: $val")
                # Note: CURL_OPTS modification inside while-read loop might not persist
                # depending on shell. Using a different approach to accumulate headers.
              fi
            done
          fi

          # Re-implementing label accumulation to ensure it persists outside the loop
          LABEL_HEADERS=()
          if [ -n "$LABELS" ]; then
            while IFS= read -r label; do
              if [[ "$label" == *"="* ]]; then
                key=$(echo "$label" | cut -d'=' -f1 | xargs)
                val=$(echo "$label" | cut -d'=' -f2- | xargs)
                LABEL_HEADERS+=("-H" "x-label-$key: $val")
              fi
            done <<< "$(echo "$LABELS" | tr ',' '\n')"
          fi

          # Execute curl
          curl "${CURL_OPTS[@]}" "${LABEL_HEADERS[@]}" --data-binary @"$OBJECT_PATH" "$URL"
